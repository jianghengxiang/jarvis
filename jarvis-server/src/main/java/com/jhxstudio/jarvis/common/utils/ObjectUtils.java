package com.jhxstudio.jarvis.common.utils;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.util.*;public class ObjectUtils {    public static Boolean isNull(Object obj) {        return obj == null;    }    public static Boolean isNotNull(Object obj) {        return !isNull(obj);    }    public static Boolean isEmpty(Object obj) {        if (obj == null) {            return true;        } else if (obj instanceof CharSequence) {            return ((CharSequence) obj).length() == 0;        } else if (obj instanceof Collection) {            return ((Collection) obj).isEmpty();        } else if (obj instanceof Map) {            return ((Map) obj).isEmpty();        } else if (obj.getClass().isArray()) {            return Array.getLength(obj) == 0;        }        return false;    }    public static Boolean isNotEmpty(Object obj) {        return !isEmpty(obj);    }    public static boolean isPrimitive(Object obj) {        return obj.getClass().isPrimitive();    }    public static boolean isPrimitiveWrapper(Object obj) {        Class clz = obj.getClass();        //ignore Void.class        if (clz.equals(Integer.class) ||                clz.equals(Byte.class) ||                clz.equals(Long.class) ||                clz.equals(Double.class) ||                clz.equals(Float.class) ||                clz.equals(Character.class) ||                clz.equals(Short.class) ||                clz.equals(Boolean.class)) {            return true;        }        return false;    }    public static boolean isBasicType(Object obj) {        return isPrimitive(obj) || isPrimitiveWrapper(obj);    }    public static Map<String, Object> object2Map(Object obj) {        Map<String, Object> map = new HashMap<>();        if (obj == null) {            return map;        }        Class clazz = obj.getClass();        Field[] fields = clazz.getDeclaredFields();        try {            for (Field field : fields) {                field.setAccessible(true);                map.put(field.getName(), field.get(obj));            }        } catch (Exception e) {            e.printStackTrace();        }        return map;    }    public static <T> T mapToObject(Map<String, Object> map, Class<?> clazz) throws Exception {        Object obj = clazz.newInstance();        if (map != null && !map.isEmpty() && map.size() > 0) {            for (Map.Entry<String, Object> entry : map.entrySet()) {                String propertyName = entry.getKey(); 	// property name                Object value = entry.getValue();		// property value                String setMethodName = "set" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);                Field field = getClassField(clazz, propertyName);	// get property which matches the map key name                if (field == null){                    continue;                }                Class<?> fieldTypeClass = field.getType();                value = convertValType(value, fieldTypeClass);                try {                    clazz.getMethod(setMethodName, field.getType()).invoke(obj, value);                } catch (NoSuchMethodException e) {                    e.printStackTrace();                }            }        }        return (T) obj;    }    private static Object convertValType(Object value, Class<?> fieldTypeClass) {        Object retVal = null;        if (Long.class.getName().equals(fieldTypeClass.getName())                || long.class.getName().equals(fieldTypeClass.getName())) {            retVal = Long.parseLong(value.toString());        } else if (Integer.class.getName().equals(fieldTypeClass.getName())                || int.class.getName().equals(fieldTypeClass.getName())) {            retVal = Integer.parseInt(value.toString());        } else if (Float.class.getName().equals(fieldTypeClass.getName())                || float.class.getName().equals(fieldTypeClass.getName())) {            retVal = Float.parseFloat(value.toString());        } else if (Double.class.getName().equals(fieldTypeClass.getName())                || double.class.getName().equals(fieldTypeClass.getName())) {            retVal = Double.parseDouble(value.toString());        } else {            retVal = value;        }        return retVal;    }    public static Field getClassField(Class<?> clazz, String fieldName) {        if (Object.class.getName().equals(clazz.getName())) {            return null;        }        Field[] declaredFields = clazz.getDeclaredFields();        for (Field field : declaredFields) {            if (field.getName().equals(fieldName)) {                return field;            }        }        //if clazz is a subclass, retrieve class field from superclass recursively        Class<?> superClass = clazz.getSuperclass();        if (superClass != null) {            return getClassField(superClass, fieldName);        }        return null;    }    public static <T> List<Map<String,Object>> objListToMapList(List<T> objList){        List<Map<String,Object>> mapList = new ArrayList<>();        if(objList == null || objList.size()==0){            return mapList;        }        for(T obj : objList){            mapList.add(object2Map(obj));        }        return mapList;    }    public static <T> List<T> setToList(Set<T> set){        if(set==null || set.isEmpty()){            return null;        }        List<T> list = new ArrayList<>();        for(T item : set){            list.add(item);        }        return list;    }}